Introduction
============

This document describes the file formats of the surviving binary data files
that encode measurement data from the Viking GCMS (gas chromatograph mass
spectrometer) instrument.

Both Viking spacecraft carried such an instrument, and several sample runs
were performed by both spacecraft. The data is available in three versions:

 * binary data files with raw measurement data
 * binary data files with processed, reduced data
 * scanned bar graphs of the processed data (originally on microfilm)

There is one data file of each kind for each sample run. It turns out that
the format of the raw data files are completely different for the Viking-1
and Viking-2 sample runs - apparently, the Viking-2 data has undergone some
processing after all, while the Viking-1 data is closer to what was actually
received from the spacecraft. However, the format of the reduced dataset is
the same for both spacecraft.

Format of the reduced dataset
=============================

Overview
--------

It seems that these files encode the transformed, calibrated results of
the mass spectrometry measurements, that is, they store current
(or equivalent) versus m/z, plus all the necessary auxiliary engineering
data. It is reasonable to assume that the bar charts on the microfilms
were generated from these files, and indeed it is possible to create
almost identical plots from them.

The format of these files seem to be the same for both instruments.
They consist of fixed size 1282 byte records. The first record serves as
a global header for storing constants and other metadata relevant to the
entire sample run. Each subsequent record contains the reduced mass
spectrum from one scan. Therefore a data file with `n` scans has a file
size of `(n+1)*1282`; this is true for all 6 Viking-1 and 10 Viking-2
files.

All actual measurement data and some of the constants in the header are
floating point numbers, however, they use an obscure and obsolete
floating point number format (after all, the now ubiquitous IEEE-754 was
not invented yet in 1977). This format appears to be that of the
IBM 1130/1800, but since available documentation is sparse, a detailed
description is warranted here.

Floating point format
---------------------

This format uses 32 bits (or 4 bytes, stored on disk as big endian) to
represent a floating point number. The first 24 bits represent the
mantissa _in two's complement_ notation. The remaining 8 bits store the
exponent (but see below).

The following figure illustrates the format:

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-------------------------------------------+---------------+
     |s:f:      Mantissa (two's complement)          |Exponent - Bias|
     +-+-+-------------------------------------------+---------------+

A few things are worth noting here.

 * The mantissa is in a two's complement form; this means that while the
   most significant bit (the `s` bit in the figure) can still be thought
   of as the sign bit (it's 0 if the number is positive and 1 if it is
   negative), it is really a part of the representation.

 * As opposed to IEEE-754 where the first bit of the mantissa is omitted
   (because it is almost always 1), here the entire mantissa is always
   encoded. The second most significant bit (the `f` bit in the figure)
   is always 1 for positive numbers. In other words, this format does
   not use hidden bit normalization.

 * Because the presence of the first bit, the actual usable precision of
   this format is one bit less than that of IEEE-754. 

 * The exponent is biased. Whether the bias is 128 or 129 depends on the
   point of view. From the examples in the table below it can be seen
   that values close to unity are encoded with an exponent of 0x81, or
   129. Given that the real value of a floating point number can be
   expressed as `v = m * 2 ** (e - bias)`, it makes more sense to say
   that the bias is 129 in this case.

 * The presence of the first bit (which conceptionally stands before the
   implied "decimal" point) has to be taken into account when writing
   conversion functions to/from this format. The point has to be shifted
   right by 22 bit positions, so the actual conversion formula to use is
   `v = m * 2 ** (e - 129 - 22)`.

 * The number 0 is encoded as 0x00000000.

 * The Rushneck et al. (1978) article about the GSMC instrument mentions
   the IBM 1800 in one of the figures, so it makes sense that the data
   files use the storage format of that computer. However, available
   descriptions (e.g. [http://www.quadibloc.com/comp/cp0201.htm] and
   [https://nssdc.gsfc.nasa.gov/nssdc/formats/IBM1130.htm]) do not
   mention that the mantissa is in two's complement form.

 * The encoded representations are not necessarily aligned to offsets
   divisible by 4. Apparently the IBM 1800 (a 16-bit machine) did not
   have the alignment requirements that modern architectures have.

Examples (taken from DR005631_F00002.PHYS):

Hex      | Binary                            | Decoded value
-------- | --------------------------------- | ----------------------
448bfc81 | 010001001000101111111100 10000001 |   1.07104396820068
84828584 | 100001001000001010000101 10000100 | -15.4362697601318
7697547c | 011101101001011101010100 01111100 |   0.0579058229923248
94249274 | 100101000010010010010010 01110100 | - 0.000205721182283014
97ada784 | 100101111010110110100111 10000100 | -13.0402088165283
70ec717a | 011100001110110001110001 01111010 |   0.0137846190482378
c0000081 | 110000000000000000000000 10000001 | - 1.0

Integer format
--------------

Most, if not all, numbers in the reduced data files that are not
floating point are 16 bit (unsigned?) integers in big endian format. In
many cases (raw measurement data or engineering parameters from the
instrument) the actual values use only 9 bits.

Header
------

The first row, 1282 bytes long, encodes a number of engineering
parameters relevant to the sample run, numerical constants used for
calibration/data processing, and a table of some parameter
for all scans in the sample run.

The following list attempts to enumerate all known fields. Offsets are
in hexadecimal notation. Type `i16` means big endian 16 bit integer,
`f` means the floating point format described above.

Offset    | Type | Meaning, notes
--------- | ---- | --------------
0000      | i16  | ?       - always 0x0005 - row start magic number?
0002-0078 | i16  | blank
0080      | i16  | ?       - always 0x0040
0082      | i16  | ?       - always 0x0040
0084-046a | i16  | table of effluent divider status, or related (?)
046c      | i16  | blank
046e      | i16  | initial mission scan number - 282 or 283
0470      | i16  | number of scans
0472      | i16  | blank
0474      | f    | Volts-to-amps (3) B
0478      | f    | Volts-to-amps (3) A
047c      | f    | Volts-to-amps (2) C
0480      | f    | Volts-to-amps (2) B
0484      | f    | Volts-to-amps (2) A
0488      | f    | Volts-to-amps (1) C
048c      | f    | Volts-to-amps (1) B
0490      | f    | Volts-to-amps (1) A
0494      | f    | Mass-compensation B
0498      | f    | Mass-compensation A
049c      | f    | Time-to-mass B
04a0      | f    | Time-to-mass A
04a4      | i16  | Last RIC used in Volts-to-amps curve 2
04a6      | i16  | Last RIC used in Volts-to-amps curve 1
04a8      | i16  | Serial Number
04aa      | i16  | Processed on day
04ac      | i16  | Processed on month
04ae      | i16  | Processed on year (last two digits)
04b0      | i16  | Run number
04b2-0501 | ???  | 80 bytes with unknown meaning

A note about the effluent divider status:

Apparently this parameter is crucial in interpreting the results.
All gas chromatogram charts in Rushneck et al. (1978) include a plot of
this parameter, and its value is necessary to calculate absolute
intensities. Yet, it is not possible to identify this parameter in the
reduced data sets with absolute certainty.

A table of some parameter, likely the effluent divider status, or
something related, is included in the header as a table of integers
starting from offset 0x0084. The table stores one value per scan, in
_reverse order_, so that scan 1 is at offset 0x046a and subsequent scans
are at decreasing offsets. In sample runs with less than 500 scans the
beginning of this table is empty. Furthermore, the values in this table
are replicated in each scan row's header (see below).

However, the representation of this value is not uniform across all data
files. In Viking-2 files 1-3, 8 they are in the range 1..5 and plotting
the table reproduces the corresponding plot in Fig. 7 of Biemann et al.
(1977) exactly. However, in the rest of the files use a different
representation (values between 0-0x26) and the plots resemble but do not
match their counterparts in the article. All Viking-1 files use this
second format. It is possible that this second format encodes the ion
pump current from which the effluent divider status was derived, but the
exact correspondence between the two is not known.

Missing/unidentified information: oven temperature, mass compensation

Scan records
------------

After the global header the data file consists of 1282 byte records,
each record encoding a single scan. The first 282 bytes are occupied by
a row header. The remaining 1000 bytes encode the actual measurement
data (intensities, or current) in linear units, one 4 byte floating
point number per m/z slot, in _reverse order_.

That means that to retrieve the value for m/z slot `n` for scan `i`, one
has to read 4 bytes from the offset `(i+1) * 1282 - n * 4`. Some slots
at the beginning and end of the data section of the record are filled
with zeroes, because the instrument measured between m/z of approx.
12 and 219, but the end of the record actually correspond to m/z 1.

Cases where one scan is missing in its entirety (the scan counter just
skips one), so the above formula has to be adjusted accordingly:

File                  | Missing no.
--------------------- | -----------
DR005631_F00001.PHYS  | 1
DR005631_F00006.PHYS  | 135

Additionally, there are several scans with no data (all zeroes).
And even in the rest of the scans with valid data there are occasionally
bad/missing points (especially near first/last scans), these are denoted
with the special value -1 (otherwise, all valid values are positive).

Row header
----------

Offsets here are in hexadecimal notation, counted from the
_beginning of the record_.

Offset    | Type | Meaning, notes
--------- | ---- | --------------
0000      | i16  | ?       - always 0x0005 - row start magic number?
0002      | i16  | MIT Scan number
0004      | i16  | GCMS Run ID number
0006      | i16  | Binary flag, 1 if data present, 0 if all zeroes
0008      | i16  | Mission scan number
000a      | i16  | effluent divider status? (same as in the header table and 0x0108)
000c      | i16  | blank
000e      | i16  | blank
0010      | i16  | Frame validity bitfield (15 bits, 0 if frame was missing or corrupt)
0012      | i16  | initial mission scan number, constant (282 or 283)
0014      | i16  | ?       - some small number (1,2,3,12) - oven number?
0016-00d6 | i16  | blank
00d8      | i16  | ?       - always 0x0004
00da-00e6 | i16  | blank
00e8      | i16  | ?       - see below
00ea      | i16  | ?
00ec      | i16  | ?
00ee      | i16  | ?
00f0      | i16  | ?
00f2      | i16  | ?
00f4      | i16  | ?
00f6      | i16  | ?
00f8      | i16  | ?       - some value around either 216 or 432, with spikes and jitter
00fa      | i16  | ?       - some value around either 64 or 128, with spikes and jitter
00fc      | i16  | ?       - some value around either 115 or 315, with spikes and jitter
00fe      | i16  | ?       - some value around either 40 or 80, with spikes and jitter
0100      | i16  | ?       - some value around either 160 or 325, with spikes and jitter
0102      | i16  | ?       - some value around either 180 or 350, with spikes and jitter
0104      | i16  | ?       - some value around either 60 or 120, with spikes and jitter
0106      | i16  | ?       - some value around either 50 or 290, with spikes and jitter
0108      | i16  | effluent divider status? (same as in the header table and at 0x000a)
010a      | i16  | ?       - repeating pattern with period 16, value range 0-511
010c      | i16  | ?       - a smooth curve, somewhat resembling the ones at 0x00e8
010e      | i16  | ?       - repeating pattern with period 16, value range 0-15
0110      | i16  | ?       - something resembling the effluent divider status, but with a range of 0-15
0112      | i16  | modulo 16 counter (range 1-16)
0114      | i16  | MIT Scan number
0116      | i16  | Mission scan number
0118      | i16  | Counter? (increases with 16/scan, but sometimes skips or resets)

The plots of the eight values at offsets 0xe8-0xf6 are very similar to
each other within the same data file, looking almost like shifted copies
of each other. They are very different between files, though. Perhaps
related to the total ion current, which was measured 8 times during each
sample run?

The note "some value around either x or y, with spikes and jitter" means
that the value is almost constant within a file, but there small
variations of 1-2 units are common and occasionally the value drops to
zero or some other value for a few scans. The location of spikes seems
to be consistent, i.e. they are at the same scans for most (all?) of
these values.

The frame validity bitfield tells whether the scan data is complete, and
if not, which parts are missing. (The data was originally sent from the
spacecraft as 15 separate frames, and in a few cases some of them were
missing or corrupt.)

Reproducing the mass spectrograms from the microfilms
-----------------------------------------------------

With the information above it is possible to reproduce almost every
aspect of the bar charts from the microfilms. The constants listed at
the start of each scanned document can be retrieved from the file
header. The only information missing is the oven temperature, the
hydrous/anhydrous status and the flag for the "no mass compensation"
notice. Perhaps these qualifiers were not stored in the data files at
all.

For the charts themselves it is enough to plot the decoded intensities
as a function of mass number, using the formula indicated above, with
any program that can produce autoscaled plots. The intensity of the
largest peak displayed above the charts is simply the value of the
largest peak from the sample run (or from the sample run, with m/z < 47
peaks suppressed), multiplied with 1e13. (The actual displayed values
seem to match exactly, confirming that the interpretation of the file
outlined in this document is correct.)

Some charts are marked with an "Incomplete scan" note and a bit string,
these correspond to scans where the frame validity bitfield is not all
ones (i.e. its numeric value is not 32767).

The most important thing missing is the effluent divider number, which
could not be reliably determined from the data.

Additionally, one can reproduce the gas chromatograms (time evolution
charts) from the Biemann et al. (1977), either for any selected m/z or
the sum of all ions. Again, the effluent divider number is sorely
missing here.


Format of the Viking-1 raw dataset
==================================

Overview
--------

These files have a rather complicated structure, they are much harder to
handle than either of the other two formats described in this document.

There is one file per sample run. Each file consists of packets of
variable lengths, written sequentially, without gaps. Each packet is
prefixed by its length, encoded as a 16 bit _little endian_ integer.
The use of little endian is surprising: it is not used anywhere else in
any of the files (and it is generally not used in wire protocols or disk
formats intended to be portable). Yet, that's how it works out.
So to parse the files, it is enough to read two bytes, decode as a
little endian integer, then read that many bytes to get the packet's
content. Repeat this until the end of file.

The size of the packet determines its kind and role. Four distinct sizes
were observed:

 * 416 bytes: "long data frame" - has a frame header and encodes 256
   packed data points i.e. a part of a scan. These frames make up the
   bulk of the files. In some files the auxiliary engineering data are
   encoded in such long frames (so the most of the frame is filled with
   0s in these cases).
 * 100 bytes: "short data frame" - has a frame header and encodes 19
   packed data points, typically the auxiliary engineering data for each
   scan. But it sometimes occurs before missing long frames, where it
   likely encodes a truncated frame, and there are a sequence of blank
   short frames (one for each blank scan) at the beginning and end of
   the files.
 * 80 bytes: fragment, or engineering data? - no frame header.
   Contains unknown binary data (which resembles the data at offset
   0x04b2 the reduced file's header). Only occurs in
   DR005289_F00004.PHYS.
 * 32 bytes: fragment or garbage? - no frame header. Mostly blank, but
   contains some non-zero values of unknown meaning in some cases.
   Occurs near missing frames.

(Sizes in the above list are without the 2 byte length prefix field.)

The most important are the long data frames. 15 of these in a make up a
complete scan. There are designated fields in the header that make it
possible to find which frames belong to which scan and in what order.
Usually frames 1-15 for the same scan are found in that order, followed
by frame 0 that encodes a set of auxiliary parameters. This last frame
is long (416 bytes) in 4 files, but short (100 bytes) in the other 2.

All files contain at least a few missing frames, which can be inferred
from the fact that the frame counter skips. Often, but not always, there
is a 32 byte packet after the last contiguous frame, and that last frame
is often corrupted (or it is a short frame, likely filled with garbage).

The "frame validity bitfield" in the reduced files' header can be
matched to the missing frames in the raw files. Frames that are missing
or corrupt in the raw files are marked as 0 in that bitfield for the
corresponding scans in the reduced file.

The header is 72 bytes long (again, without the initial length prefix),
leaving either 344 or 28 bytes for the payload. As for the data points
themselves, values are 9-bit unsigned integers, three of which are
packed into a 32 bit (4 byte) block. This means that a long frame could
store `344 / 4 * 3 = 258` values, but the last two slots are always
unused, so a long frame contains 256 values in the end. Similarly,
a short frame contains `28 / 4 * 3 - 2 = 19` values.

The 80 and 32 byte packets don't seem to use this integer packing
scheme.

Integer packing
---------------

Three 9 bit integers are packed without gaps into a 32 bit field so that
the remaining 5 lowest bits are always blank.

The following figure illustrates the format:

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-----------------+-----------------+-----------------+---------+
     |   First value   |  Second value   |   Third value   |0 0 0 0 0|
     +-----------------+-----------------+-----------------+---------+

The literature (Rushneck et al., 1978) states that most quantities,
including the main measurement data (resolved ion current) were sampled
at 9 bit resolution. It is not known if this peculiar encoding scheme
was already used by the spacecraft when the data was originally
transmitted from Mars, or it was introduced during ground processing to
make it easier to handle data on a computer with a 32 bit word size.

Frame header
------------

Offsets here are in hexadecimal notation, counted from the
_beginning of the frame_, not including the length prefix field.

Offset    | Type  | Meaning, notes
--------- | ----  | --------------
xx        | i16le | length  - either 0x6400 (short frames) or 0xa001 (long frames)
00        | i8    | ?       - modulo 18 counter (avg period ~18.3)
01        | i8    | blank
02        | i16   | ?       - something related to packet size, type, contents, or modulo 16 counter?
04        | i32   | millisecond-of-day counter, resets at 86400000
08        | i16   | ?       - always 0x1b00
0a        | i16   | day counter?
0c        | i8    | ?       - either 0x0b or 0x73 (file 4)
0d        | i8    | modulo 16 counter, 2 for frame 0, 1 otherwise
0e-11     | ???   | ?       - 4 bytes, always 0x02040076
12        | i16   | ?       - fluctuating around a file-dependent constant
14        | i16   | ?       - either 0x0e00 or 0x2b00
16        | i16   | ?       - either 0x0a29 or 0x1d72
18        | i16   | ?       - almost always 0x6800 (except for a few spikes to 0x6804)
1a        | i16   | ?       - almost, but not quite the value at offset 2, times 8
1c-1f     | ???   | ?       - 4 bytes, always 0x1a000fa0
20        | i8    | blank
21        | i8    | ?       - almost always 0x12 or 0x11 (except for a few +1 spikes)
22        | i8    | ?       - file-dependent value with lot of random-looking noise
23-27     | i8    | blank
28        | i16   | frame counter (continuous, but with varying starting offset, few skips mid-file and jumps backwards near first scan)
2a        | i16   | ?       - almost always 0xc3 or 0xc2 (with one -1 spike)
2c        | i8    | ?       - always 0x41
2d        | i16   | scan counter (i16 but not aligned to 2 byte boundary!)
2f        | i8    | frame counter (intra-scan, range 0-15)
30-33     | i8    | ?       - 4 bytes, blank for data frames (but non-zero in the empty frames before scans)
34        | i16   | blank
36        | i8    | reset counter (increases every time there is a missed frame, but with starting offset and spikes)
37-38     | i8    | blank
39        | i16   | frame counter (continuous, i16 but not aligned to 2 byte boundary!)
3b        | i8    | ?       - file-dependent constant
3c        | i16   | ?       - 4 bytes, blank for data frames (but non-zero in the empty frames before scans)
3e        | i16   | ?       - 4 bytes, blank for data frames (but non-zero in the empty frames before scans)
40-43     | i8    | blank
44        | i32   | ?       - always 0x04b3e375 (signature for end of header?)

Auxiliary data frames
---------------------

Every 16th frame (the last one in a scan, with the modulo 16 frame
counter = 0) encodes a set of engineering parameters. These are the same
as the ones in the record headers of the reduced format (and those in
the record headers in the Viking-2 raw format, for that matter), but in
a different order.

Since the frame body uses the same integer packing scheme as the main
data frames, it's not useful to give their locations as byte offsets, so
they're listed in the order they are stored instead.

RRH refers to the row header table in the reduced dataset.

Index | Type | Meaning, notes
----- | ---- | --------------
1     | i9   | ?     - the suspected effluent divider curve, rescaled, with a modulo 16 pattern overlaid
2     | i9   | ?     - same as RRH 0x10c, but rescaled: reduced = raw/2+256
3     | i9   | ?     - same as 0x10a (partial match)
4     | i9   | ?     - same as RRH 0x106
5     | i9   | ?     - same as RRH 0x0f6
6     | i9   | ?     - same as RRH 0x104
7     | i9   | ?     - same as RRH 0x0f4
8     | i9   | ?     - same as RRH 0x102
9     | i9   | ?     - same as RRH 0x0f2
10    | i9   | ?     - same as RRH 0x100
11    | i9   | ?     - same as RRH 0x0f0
12    | i9   | ?     - same as RRH 0x0fe
13    | i9   | ?     - same as RRH 0x0ee
14    | i9   | ?     - same as RRH 0x0fc
15    | i9   | ?     - same as RRH 0x0ec
16    | i9   | ?     - same as RRH 0x0fa
17    | i9   | ?     - same as RRH 0x0ea
18    | i9   | ?     - same as RRH 0x0f8
19    | i9   | ?     - same as RRH 0x0e8

The first value in the frame is actually the combination of the effluent
divider status (or the mysterious quantity used to derive it) and the
modulo 16 repeating pattern.
The topmost 5 bits of the first value is the same as effluent divider
status at offset 0xa of the RRH, minus 23. The bottom 4 bits is the
repeating pattern, which is similar to the one at offset 0x010e of
the RRH, but not exactly the same.


Assembling and converting the scan
----------------------------------

Because of the complicated file structure described above, it is not
feasible to express the position of a given data point with a simple,
general formula. One has to parse the file packet by packet and
reassemble the scans, paying particular attention to missing frames.

Each long data frame contains 256 packed 9 bit integers, so 15 of those
frames store the 3840 data points that make up one scan.

The measurement data encodes the logarithm of the resolved ion current
(or rather, a voltage between 0-5 V that is related to that quantity
through an calibration curve that is not yet known), encoded as a 9 bit
integer (range 0-511). The scale is inverted: higher values correspond
to _lower_ current (unlike in the Viking-2 "raw" files).

The instrument worked by sweeping the voltage exponentially from 2350 V
down to 125 V (corresponding to a m/z range of approx. 11.5-215), taking
3840 samples with a fixed cadence - which means that an exponential-like
transformation needs to be applied to the sample number to get to m/z
units. The samples are stored in order, meaning that samples
corresponding to low m/z are stored first in the frames, and the frames
also follow in order of low to high m/z.

Anomalies
---------

In one case (DR005289_F00004.PHYS) the scan counter jumps back for a few
frames around a missing frame, but neither the frame timestamp nor the
overall frame counter skips, so perhaps the scan counter is wrong here.

TODO more

Format of the Viking-2 raw dataset
==================================

Even though we call these files the "raw" dataset, they seem to have
undergone some kind of processing on the ground before archival.

Every file consists of fixed size 7802 byte records. Each record
corresponds to one scan. There is no global file header or footer, and
the sample run id is not to be found anywere in the file, which is a
pity. This means that a raw data file with `n` scans has a file size of
`n*7802`; this is true for all 10 Viking-2 files, but some of them have
missing scans in the middle of the file (fortunately the scan counters
in the headers make it possible to identify these cases).

Each record is made up of a 122 byte header and 7680 bytes of data.
All values are encoded as big endian unsigned 16 bit integers, so there
are 61 values in the header and 3840 values for the measurement channels
for one scan. Many values in the header and all in the data section use
9 bits only (range 0-511). This is in accordance with the available
literature (which states that most quantities were sampled at 9 bit
resolution). The integer packing scheme found in the Viking 1 files is
not used here at all.

The measurement data encodes the logarithm of the resolved ion current
(or rather, a voltage between 0-5 V that is related to that quantity
through a calibration curve that is not yet known), encoded as a 9 bit
integer. Here higher values correspond to higher current (unlike in the
Viking-1 raw files).

The instrument worked by sweeping the voltage exponentially from 2350 V
down to 125 V (corresponding to a m/z range of approx. 11.5-215), taking
3840 samples with a fixed cadence - which means that an exponential-like
transformation needs to be applied to the sample number to get to m/z
units. It is important to note that in the Viking-2 raw files the
samples are stored in _reverse order_, meaning that samples
corresponding to high m/z are stored first in the record.

In any case, to get the sample `i` from sample `n`, read 2 bytes from
offset `7802*n + 122 + 2*i`.


Row header
----------

Offsets here are in hexadecimal notation, counted from the
_beginning of the record_. RRH refers to the row header table in the
reduced dataset.

Offset    | Type | Meaning, notes
--------- | ---- | --------------
00        | i16  | ?       - always 0x781e - row start magic number?
02-2c     | i16  | blank
2e        | i16  | ?       - some small number (1,2,3,12) - oven number? (same as RRH 0x14)
30        | i16  | initial mission scan number, constant (282 or 283) (same as RRH 0x12)
32-3a     | i16  | blank
3c        | i16  | ?       - 0, except for DR005967_F00007 where it changes to 1 mid-file
3e        | i16  | ?       - 0, except for DR005967_F00007 where it changes to 4474 mid-file
40-4e     | i16  | ?       - 8 similar, shifted curves, similar to RRH 0xe8-0xf6
50        | i16  | ?       - some value around either 216 or 432, with spikes and jitter
52        | i16  | ?       - some value around either 64 or 128, with spikes and jitter
54        | i16  | ?       - some value around either 115 or 315, with spikes and jitter
56        | i16  | ?       - some value around either 40 or 80, with spikes and jitter
58        | i16  | ?       - some value around either 160 or 325, with spikes and jitter
5a        | i16  | ?       - some value around either 185 or 350, with spikes and jitter
5c        | i16  | ?       - some value around either 62 or 126, with spikes and jitter
5e        | i16  | ?       - some value around either 77 or 294, with spikes and jitter
60        | i16  | effluent divider status?
62        | i16  | ?       - repeating pattern with period 16, value range 0-511
64        | i16  | ?       - a smooth curve, somewhat resembling the ones at 0x40
66        | i16  | ?       - repeating pattern with period 16, value range 0-15
68        | i16  | ?       - something resembling the effluent divider status, but with a range of 0-15
6a        | i16  | modulo 16 counter (range 1-16)
6c        | i16  | MIT Scan number
6e        | i16  | Mission scan number
70        | i16  | Counter? (increases with 16/scan, but sometimes skips or resets)
72        | i16  | ?       - mostly 0, but with spikes to 1 and in some files it switches to 1 mid-file
74        | i16  | ?       - mostly 1, but in some files it switches to 0 near end of file
76        | i16  | Frame validity bitfield (same as RRH 0x10)
78        | i16  | Mission scan number

The note "some value around either x or y, with spikes and jitter" means
that the value is almost constant within a file, but there small
variations of 1-2 units are common and occasionally the value drops to
zero or some other value for a few scans. The location of spikes seems
to be consistent, i.e. they are at the same scans for most (all?) of
these values.

The values between offsets 0x40-0x70 seem to be the same as the values
in the reduced row headers offsets 0xe8-0x118 (apart from missing scans
in the raw files).

Conversion between the raw and reduced data
==============================================

The raw data consist of log-scaled ion current (actually, A/D-converted
voltage) samples encoded as 9 bit integers, as a function of sampling
time (actually, position within the scan). The reduced data consist of
linear ion current values as a function of m/z. Clearly, both axes have
to be transformed.

For the x axis (sample position to m/z) the Time-to-mass A and B
constants from the processed file's header are to be used. (The same
constants are listed in the preface of the microfilms, so we know that
they are decoded correctly.) The function `10**(A * x + B)` gives an
suitable exponential transformation function that maps the [0, 3840]
range to [11.8, 218.8]. The peaks don't appear to fall to integer m/z's
when using this transformation function. A possible interpretation of
Rushneck et al. (1977) is that to derive the resolved ion current for a
given m, one has to find the highest value from the samples that fall
within the range [m-0.5, 0+0.5] and use that value for subsequent
calculations.

For the y axis (sampled voltage to calibrated ion current) there are 
three sets of constants in the header, but the transformation functions
in which to use them are not yet known.

There is a third set of constants, labelled "mass compensation", but it
is not known how or where to use them.
